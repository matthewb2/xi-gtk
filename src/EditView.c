/* EditView.c generated by valac 0.56.18, the Vala compiler
 * generated from EditView.vala, do not modify */

/* Copyright 2016-2019 Elias Aebi*/
/**/
/* Licensed under the Apache License, Version 2.0 (the "License");*/
/* you may not use this file except in compliance with the License.*/
/* You may obtain a copy of the License at*/
/**/
/*     http://www.apache.org/licenses/LICENSE-2.0*/
/**/
/* Unless required by applicable law or agreed to in writing, software*/
/* distributed under the License is distributed on an "AS IS" BASIS,*/
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and*/
/* limitations under the License.*/

#include <gtk/gtk.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gio/gio.h>
#include <gtk/gtkimmodule.h>
#include <float.h>
#include <math.h>
#include <cairo-gobject.h>
#include <gdk/gdk.h>
#include <json-glib/json-glib.h>
#include <pango/pango.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define XI_TYPE_EDIT_VIEW (xi_edit_view_get_type ())
#define XI_EDIT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XI_TYPE_EDIT_VIEW, XiEditView))
#define XI_EDIT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XI_TYPE_EDIT_VIEW, XiEditViewClass))
#define XI_IS_EDIT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XI_TYPE_EDIT_VIEW))
#define XI_IS_EDIT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XI_TYPE_EDIT_VIEW))
#define XI_EDIT_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XI_TYPE_EDIT_VIEW, XiEditViewClass))

typedef struct _XiEditView XiEditView;
typedef struct _XiEditViewClass XiEditViewClass;
typedef struct _XiEditViewPrivate XiEditViewPrivate;

#define XI_TYPE_CORE_CONNECTION (xi_core_connection_get_type ())
#define XI_CORE_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XI_TYPE_CORE_CONNECTION, XiCoreConnection))
#define XI_CORE_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XI_TYPE_CORE_CONNECTION, XiCoreConnectionClass))
#define XI_IS_CORE_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XI_TYPE_CORE_CONNECTION))
#define XI_IS_CORE_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XI_TYPE_CORE_CONNECTION))
#define XI_CORE_CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XI_TYPE_CORE_CONNECTION, XiCoreConnectionClass))

typedef struct _XiCoreConnection XiCoreConnection;
typedef struct _XiCoreConnectionClass XiCoreConnectionClass;

#define XI_TYPE_LINE_CACHE (xi_line_cache_get_type ())
#define XI_LINE_CACHE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XI_TYPE_LINE_CACHE, XiLineCache))
#define XI_LINE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XI_TYPE_LINE_CACHE, XiLineCacheClass))
#define XI_IS_LINE_CACHE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XI_TYPE_LINE_CACHE))
#define XI_IS_LINE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XI_TYPE_LINE_CACHE))
#define XI_LINE_CACHE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XI_TYPE_LINE_CACHE, XiLineCacheClass))

typedef struct _XiLineCache XiLineCache;
typedef struct _XiLineCacheClass XiLineCacheClass;

#define XI_TYPE_BLINKER (xi_blinker_get_type ())
#define XI_BLINKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XI_TYPE_BLINKER, XiBlinker))
#define XI_BLINKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XI_TYPE_BLINKER, XiBlinkerClass))
#define XI_IS_BLINKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XI_TYPE_BLINKER))
#define XI_IS_BLINKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XI_TYPE_BLINKER))
#define XI_BLINKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XI_TYPE_BLINKER, XiBlinkerClass))

typedef struct _XiBlinker XiBlinker;
typedef struct _XiBlinkerClass XiBlinkerClass;
enum  {
	XI_EDIT_VIEW_0_PROPERTY,
	XI_EDIT_VIEW_LABEL_PROPERTY,
	XI_EDIT_VIEW_HAS_UNSAVED_CHANGES_PROPERTY,
	XI_EDIT_VIEW_HADJUSTMENT_PROPERTY,
	XI_EDIT_VIEW_HSCROLL_POLICY_PROPERTY,
	XI_EDIT_VIEW_VADJUSTMENT_PROPERTY,
	XI_EDIT_VIEW_VSCROLL_POLICY_PROPERTY,
	XI_EDIT_VIEW_NUM_PROPERTIES
};
static GParamSpec* xi_edit_view_properties[XI_EDIT_VIEW_NUM_PROPERTIES];
#define _xi_core_connection_unref0(var) ((var == NULL) ? NULL : (var = (xi_core_connection_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _xi_line_cache_unref0(var) ((var == NULL) ? NULL : (var = (xi_line_cache_unref (var), NULL)))
#define _xi_blinker_unref0(var) ((var == NULL) ? NULL : (var = (xi_blinker_unref (var), NULL)))

#define XI_TYPE_LINE (xi_line_get_type ())
#define XI_LINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XI_TYPE_LINE, XiLine))
#define XI_LINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XI_TYPE_LINE, XiLineClass))
#define XI_IS_LINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XI_TYPE_LINE))
#define XI_IS_LINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XI_TYPE_LINE))
#define XI_LINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XI_TYPE_LINE, XiLineClass))

typedef struct _XiLine XiLine;
typedef struct _XiLineClass XiLineClass;
#define _xi_line_unref0(var) ((var == NULL) ? NULL : (var = (xi_line_unref (var), NULL)))
#define _pango_font_metrics_unref0(var) ((var == NULL) ? NULL : (var = (pango_font_metrics_unref (var), NULL)))

#define XI_TYPE_THEME (xi_theme_get_type ())
#define XI_THEME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), XI_TYPE_THEME, XiTheme))
#define XI_THEME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), XI_TYPE_THEME, XiThemeClass))
#define XI_IS_THEME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), XI_TYPE_THEME))
#define XI_IS_THEME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), XI_TYPE_THEME))
#define XI_THEME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), XI_TYPE_THEME, XiThemeClass))

typedef struct _XiTheme XiTheme;
typedef struct _XiThemeClass XiThemeClass;
typedef struct _XiThemePrivate XiThemePrivate;
#define _xi_theme_unref0(var) ((var == NULL) ? NULL : (var = (xi_theme_unref (var), NULL)))
#define __vala_GdkEventSequence_free0(var) ((var == NULL) ? NULL : (var = (_vala_GdkEventSequence_free (var), NULL)))
#define __vala_GdkEvent_free0(var) ((var == NULL) ? NULL : (var = (_vala_GdkEvent_free (var), NULL)))
#define _json_object_unref0(var) ((var == NULL) ? NULL : (var = (json_object_unref (var), NULL)))
enum  {
	XI_EDIT_VIEW_SEND_EDIT_SIGNAL,
	XI_EDIT_VIEW_COPY_SIGNAL,
	XI_EDIT_VIEW_CUT_SIGNAL,
	XI_EDIT_VIEW_PASTE_SIGNAL,
	XI_EDIT_VIEW_ADD_NEXT_TO_SELECTION_SIGNAL,
	XI_EDIT_VIEW_NUM_SIGNALS
};
static guint xi_edit_view_signals[XI_EDIT_VIEW_NUM_SIGNALS] = {0};

struct _XiEditView {
	GtkDrawingArea parent_instance;
	XiEditViewPrivate * priv;
};

struct _XiEditViewClass {
	GtkDrawingAreaClass parent_class;
	void (*send_edit) (XiEditView* self, const gchar* method);
	void (*copy) (XiEditView* self);
	void (*cut) (XiEditView* self);
	void (*paste) (XiEditView* self);
	void (*add_next_to_selection) (XiEditView* self);
};

struct _XiEditViewPrivate {
	XiCoreConnection* core_connection;
	gchar* view_id;
	GFile* file;
	GtkIMContext* im_context;
	GtkGestureMultiPress* multipress_gesture;
	GtkGestureDrag* drag_gesture;
	GtkBorder padding;
	XiLineCache* line_cache;
	gdouble ascent;
	gdouble line_height;
	gdouble char_width;
	gint64 first_line;
	gint64 last_line;
	gdouble gutter_width;
	XiBlinker* blinker;
	gchar* _label;
	gboolean _has_unsaved_changes;
	GtkAdjustment* _hadjustment;
	GtkScrollablePolicy _hscroll_policy;
	GtkAdjustment* _vadjustment;
	GtkScrollablePolicy _vscroll_policy;
};

struct _XiTheme {
	GTypeInstance parent_instance;
	volatile int ref_count;
	XiThemePrivate * priv;
	GdkRGBA foreground;
	GdkRGBA background;
	GdkRGBA caret;
	GdkRGBA line_highlight;
	GdkRGBA selection;
	GdkRGBA gutter;
	GdkRGBA gutter_foreground;
	GdkRGBA find_highlight;
	GdkRGBA find_highlight_foreground;
};

struct _XiThemeClass {
	GTypeClass parent_class;
	void (*finalize) (XiTheme *self);
};

static gint XiEditView_private_offset;
static gpointer xi_edit_view_parent_class = NULL;
static GtkScrollableInterface * xi_edit_view_gtk_scrollable_parent_iface = NULL;

VALA_EXTERN GType xi_edit_view_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (XiEditView, g_object_unref)
VALA_EXTERN gpointer xi_core_connection_ref (gpointer instance);
VALA_EXTERN void xi_core_connection_unref (gpointer instance);
VALA_EXTERN GParamSpec* xi_param_spec_core_connection (const gchar* name,
                                           const gchar* nick,
                                           const gchar* blurb,
                                           GType object_type,
                                           GParamFlags flags);
VALA_EXTERN void xi_value_set_core_connection (GValue* value,
                                   gpointer v_object);
VALA_EXTERN void xi_value_take_core_connection (GValue* value,
                                    gpointer v_object);
VALA_EXTERN gpointer xi_value_get_core_connection (const GValue* value);
VALA_EXTERN GType xi_core_connection_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (XiCoreConnection, xi_core_connection_unref)
VALA_EXTERN gpointer xi_line_cache_ref (gpointer instance);
VALA_EXTERN void xi_line_cache_unref (gpointer instance);
VALA_EXTERN GParamSpec* xi_param_spec_line_cache (const gchar* name,
                                      const gchar* nick,
                                      const gchar* blurb,
                                      GType object_type,
                                      GParamFlags flags);
VALA_EXTERN void xi_value_set_line_cache (GValue* value,
                              gpointer v_object);
VALA_EXTERN void xi_value_take_line_cache (GValue* value,
                               gpointer v_object);
VALA_EXTERN gpointer xi_value_get_line_cache (const GValue* value);
VALA_EXTERN GType xi_line_cache_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (XiLineCache, xi_line_cache_unref)
VALA_EXTERN gpointer xi_blinker_ref (gpointer instance);
VALA_EXTERN void xi_blinker_unref (gpointer instance);
VALA_EXTERN GParamSpec* xi_param_spec_blinker (const gchar* name,
                                   const gchar* nick,
                                   const gchar* blurb,
                                   GType object_type,
                                   GParamFlags flags);
VALA_EXTERN void xi_value_set_blinker (GValue* value,
                           gpointer v_object);
VALA_EXTERN void xi_value_take_blinker (GValue* value,
                            gpointer v_object);
VALA_EXTERN gpointer xi_value_get_blinker (const GValue* value);
VALA_EXTERN GType xi_blinker_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (XiBlinker, xi_blinker_unref)
VALA_EXTERN void xi_core_connection_send_close_view (XiCoreConnection* self,
                                         const gchar* view_id);
static gboolean xi_edit_view_real_get_border (GtkScrollable* base,
                                       GtkBorder* border);
static gint64 xi_edit_view_get_line (XiEditView* self,
                              gdouble y);
static gint64 xi_edit_view_get_index (XiEditView* self,
                               gdouble x,
                               gint64 line);
VALA_EXTERN gpointer xi_line_ref (gpointer instance);
VALA_EXTERN void xi_line_unref (gpointer instance);
VALA_EXTERN GParamSpec* xi_param_spec_line (const gchar* name,
                                const gchar* nick,
                                const gchar* blurb,
                                GType object_type,
                                GParamFlags flags);
VALA_EXTERN void xi_value_set_line (GValue* value,
                        gpointer v_object);
VALA_EXTERN void xi_value_take_line (GValue* value,
                         gpointer v_object);
VALA_EXTERN gpointer xi_value_get_line (const GValue* value);
VALA_EXTERN GType xi_line_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (XiLine, xi_line_unref)
VALA_EXTERN XiLine* xi_line_cache_get_line (XiLineCache* self,
                                gint64 index);
VALA_EXTERN gint xi_line_x_to_index (XiLine* self,
                         gdouble x);
static gdouble xi_edit_view_get_y (XiEditView* self,
                            gint64 line);
VALA_EXTERN XiEditView* xi_edit_view_new (XiCoreConnection* core_connection,
                              const gchar* view_id,
                              GFile* file);
VALA_EXTERN XiEditView* xi_edit_view_construct (GType object_type,
                                    XiCoreConnection* core_connection,
                                    const gchar* view_id,
                                    GFile* file);
static void xi_edit_view_handle_update (XiEditView* self,
                                 JsonObject* update);
static void _xi_edit_view_handle_update_xi_core_connection_update_received (XiCoreConnection* _sender,
                                                                     JsonObject* update,
                                                                     gpointer self);
static void xi_edit_view_handle_scroll_to (XiEditView* self,
                                    gint64 line,
                                    gint64 col);
static void _xi_edit_view_handle_scroll_to_xi_core_connection_scroll_to_received (XiCoreConnection* _sender,
                                                                           gint64 line,
                                                                           gint64 col,
                                                                           gpointer self);
static void xi_edit_view_handle_commit (XiEditView* self,
                                 const gchar* str);
static void _xi_edit_view_handle_commit_gtk_im_context_commit (GtkIMContext* _sender,
                                                        const gchar* str,
                                                        gpointer self);
static void xi_edit_view_handle_pressed (XiEditView* self,
                                  gint n_press,
                                  gdouble x,
                                  gdouble y);
static void _xi_edit_view_handle_pressed_gtk_gesture_multi_press_pressed (GtkGestureMultiPress* _sender,
                                                                   gint n_press,
                                                                   gdouble x,
                                                                   gdouble y,
                                                                   gpointer self);
static void xi_edit_view_handle_drag_update (XiEditView* self,
                                      gdouble offset_x,
                                      gdouble offset_y);
static void _xi_edit_view_handle_drag_update_gtk_gesture_drag_drag_update (GtkGestureDrag* _sender,
                                                                    gdouble offset_x,
                                                                    gdouble offset_y,
                                                                    gpointer self);
VALA_EXTERN XiLineCache* xi_line_cache_new (PangoContext* context,
                                PangoFontDescription* font_description);
VALA_EXTERN XiLineCache* xi_line_cache_construct (GType object_type,
                                      PangoContext* context,
                                      PangoFontDescription* font_description);
VALA_EXTERN XiBlinker* xi_blinker_new (guint interval);
VALA_EXTERN XiBlinker* xi_blinker_construct (GType object_type,
                                 guint interval);
static void _gtk_widget_queue_draw_xi_blinker_redraw (XiBlinker* _sender,
                                               gpointer self);
static void xi_edit_view_set_label (XiEditView* self,
                             const gchar* value);
static void xi_edit_view_real_realize (GtkWidget* base);
static void xi_edit_view_real_size_allocate (GtkWidget* base,
                                      GtkAllocation* allocation);
VALA_EXTERN void xi_core_connection_send_scroll (XiCoreConnection* self,
                                     const gchar* view_id,
                                     gint64 first_line,
                                     gint64 last_line);
VALA_EXTERN gint64 xi_line_cache_get_height (XiLineCache* self);
static gboolean xi_edit_view_real_draw (GtkWidget* base,
                                 cairo_t* cr);
VALA_EXTERN gpointer xi_theme_ref (gpointer instance);
VALA_EXTERN void xi_theme_unref (gpointer instance);
VALA_EXTERN GParamSpec* xi_param_spec_theme (const gchar* name,
                                 const gchar* nick,
                                 const gchar* blurb,
                                 GType object_type,
                                 GParamFlags flags);
VALA_EXTERN void xi_value_set_theme (GValue* value,
                         gpointer v_object);
VALA_EXTERN void xi_value_take_theme (GValue* value,
                          gpointer v_object);
VALA_EXTERN gpointer xi_value_get_theme (const GValue* value);
VALA_EXTERN GType xi_theme_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (XiTheme, xi_theme_unref)
VALA_EXTERN XiTheme* xi_theme_get_instance (void);
VALA_EXTERN void xi_line_draw_background (XiLine* self,
                              cairo_t* cr,
                              gdouble x,
                              gdouble y,
                              gdouble width,
                              gdouble line_height);
VALA_EXTERN void xi_line_draw (XiLine* self,
                   cairo_t* cr,
                   gdouble x,
                   gdouble y,
                   gdouble ascent);
VALA_EXTERN gboolean xi_blinker_draw_cursor (XiBlinker* self);
VALA_EXTERN void xi_line_draw_cursors (XiLine* self,
                           cairo_t* cr,
                           gdouble x,
                           gdouble y,
                           gdouble line_height);
VALA_EXTERN void xi_line_draw_gutter (XiLine* self,
                          cairo_t* cr,
                          gdouble x,
                          gdouble y,
                          gdouble ascent);
static gboolean xi_edit_view_real_focus_in_event (GtkWidget* base,
                                           GdkEventFocus* event);
VALA_EXTERN void xi_blinker_restart (XiBlinker* self);
static gboolean xi_edit_view_real_focus_out_event (GtkWidget* base,
                                            GdkEventFocus* event);
VALA_EXTERN void xi_blinker_stop (XiBlinker* self);
static gboolean xi_edit_view_real_key_press_event (GtkWidget* base,
                                            GdkEventKey* event);
static gboolean xi_edit_view_real_key_release_event (GtkWidget* base,
                                              GdkEventKey* event);
VALA_EXTERN void xi_core_connection_send_insert (XiCoreConnection* self,
                                     const gchar* view_id,
                                     const gchar* chars);
static GdkEvent* _vala_GdkEvent_copy (GdkEvent* self);
static void _vala_GdkEventSequence_free (GdkEventSequence* self);
VALA_EXTERN void xi_core_connection_send_gesture_select_extend (XiCoreConnection* self,
                                                    const gchar* view_id,
                                                    gint64 line,
                                                    gint64 col,
                                                    const gchar* granularity);
VALA_EXTERN void xi_core_connection_send_gesture_select (XiCoreConnection* self,
                                             const gchar* view_id,
                                             gint64 line,
                                             gint64 col,
                                             const gchar* granularity,
                                             gboolean multi);
static void _vala_GdkEvent_free (GdkEvent* self);
VALA_EXTERN void xi_core_connection_send_gesture_drag (XiCoreConnection* self,
                                           const gchar* view_id,
                                           gint64 line,
                                           gint64 col);
static void xi_edit_view_handle_scroll (XiEditView* self);
VALA_EXTERN void xi_line_cache_update (XiLineCache* self,
                           JsonObject* update);
VALA_EXTERN gint xi_utilities_get_digits (gint64 number);
static void xi_edit_view_set_has_unsaved_changes (XiEditView* self,
                                           gboolean value);
static void xi_edit_view_paste_primary (XiEditView* self);
static void __lambda4_ (XiEditView* self,
                 GtkClipboard* clipboard,
                 const gchar* text);
VALA_EXTERN void xi_core_connection_send_paste (XiCoreConnection* self,
                                    const gchar* view_id,
                                    const gchar* chars);
static void ___lambda4__gtk_clipboard_text_received_func (GtkClipboard* clipboard,
                                                   const gchar* text,
                                                   gpointer self);
VALA_EXTERN gboolean xi_edit_view_save (XiEditView* self);
VALA_EXTERN void xi_core_connection_send_save (XiCoreConnection* self,
                                   const gchar* view_id,
                                   const gchar* file_path);
VALA_EXTERN void xi_edit_view_save_as (XiEditView* self,
                           GFile* file);
VALA_EXTERN const gchar* xi_edit_view_get_label (XiEditView* self);
VALA_EXTERN gboolean xi_edit_view_get_has_unsaved_changes (XiEditView* self);
VALA_EXTERN GtkAdjustment* xi_edit_view_get_hadjustment (XiEditView* self);
VALA_EXTERN void xi_edit_view_set_hadjustment (XiEditView* self,
                                   GtkAdjustment* value);
VALA_EXTERN GtkScrollablePolicy xi_edit_view_get_hscroll_policy (XiEditView* self);
VALA_EXTERN void xi_edit_view_set_hscroll_policy (XiEditView* self,
                                      GtkScrollablePolicy value);
VALA_EXTERN GtkAdjustment* xi_edit_view_get_vadjustment (XiEditView* self);
VALA_EXTERN void xi_edit_view_set_vadjustment (XiEditView* self,
                                   GtkAdjustment* value);
static void _xi_edit_view_handle_scroll_gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                                               gpointer self);
VALA_EXTERN GtkScrollablePolicy xi_edit_view_get_vscroll_policy (XiEditView* self);
VALA_EXTERN void xi_edit_view_set_vscroll_policy (XiEditView* self,
                                      GtkScrollablePolicy value);
static void xi_edit_view_real_send_edit (XiEditView* self,
                                  const gchar* method);
VALA_EXTERN void xi_core_connection_send_edit (XiCoreConnection* self,
                                   const gchar* view_id,
                                   const gchar* method,
                                   JsonObject* edit_params);
static void xi_edit_view_real_copy (XiEditView* self);
VALA_EXTERN void xi_core_connection_send_copy (XiCoreConnection* self,
                                   const gchar* view_id,
                                   GAsyncReadyCallback _callback_,
                                   gpointer _user_data_);
VALA_EXTERN gchar* xi_core_connection_send_copy_finish (XiCoreConnection* self,
                                            GAsyncResult* _res_);
static void __lambda5_ (XiEditView* self,
                 GObject* obj,
                 GAsyncResult* res);
static void ___lambda5__gasync_ready_callback (GObject* source_object,
                                        GAsyncResult* res,
                                        gpointer self);
static void xi_edit_view_real_cut (XiEditView* self);
VALA_EXTERN void xi_core_connection_send_cut (XiCoreConnection* self,
                                  const gchar* view_id,
                                  GAsyncReadyCallback _callback_,
                                  gpointer _user_data_);
VALA_EXTERN gchar* xi_core_connection_send_cut_finish (XiCoreConnection* self,
                                           GAsyncResult* _res_);
static void __lambda6_ (XiEditView* self,
                 GObject* obj,
                 GAsyncResult* res);
static void ___lambda6__gasync_ready_callback (GObject* source_object,
                                        GAsyncResult* res,
                                        gpointer self);
static void xi_edit_view_real_paste (XiEditView* self);
static void __lambda7_ (XiEditView* self,
                 GtkClipboard* clipboard,
                 const gchar* text);
static void ___lambda7__gtk_clipboard_text_received_func (GtkClipboard* clipboard,
                                                   const gchar* text,
                                                   gpointer self);
static void xi_edit_view_real_add_next_to_selection (XiEditView* self);
VALA_EXTERN void xi_core_connection_send_selection_for_find (XiCoreConnection* self,
                                                 const gchar* view_id,
                                                 gboolean case_sensitive);
VALA_EXTERN void xi_core_connection_send_find_next (XiCoreConnection* self,
                                        const gchar* view_id,
                                        gboolean wrap_around,
                                        gboolean allow_same,
                                        const gchar* modify_selection);
static void xi_edit_view_finalize (GObject * obj);
static GType xi_edit_view_get_type_once (void);
static void _vala_xi_edit_view_get_property (GObject * object,
                                      guint property_id,
                                      GValue * value,
                                      GParamSpec * pspec);
static void _vala_xi_edit_view_set_property (GObject * object,
                                      guint property_id,
                                      const GValue * value,
                                      GParamSpec * pspec);

static inline gpointer
xi_edit_view_get_instance_private (XiEditView* self)
{
	return G_STRUCT_MEMBER_P (self, XiEditView_private_offset);
}

static gboolean
xi_edit_view_real_get_border (GtkScrollable* base,
                              GtkBorder* border)
{
	XiEditView * self;
	GtkBorder _vala_border = {0};
	gboolean result;
	self = (XiEditView*) base;
	memset (&_vala_border, 0, sizeof (GtkBorder));
	result = FALSE;
	if (border) {
		*border = _vala_border;
	}
	return result;
}

static gint64
xi_edit_view_get_line (XiEditView* self,
                       gdouble y)
{
	GtkAdjustment* _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	GtkBorder _tmp3_;
	gint64 result;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->_vadjustment;
	_tmp1_ = gtk_adjustment_get_value (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->padding;
	result = MAX ((gint64) 0, (gint64) (((_tmp2_ + y) - _tmp3_.top) / self->priv->line_height));
	return result;
}

static gint64
xi_edit_view_get_index (XiEditView* self,
                        gdouble x,
                        gint64 line)
{
	XiLine* _line = NULL;
	XiLineCache* _tmp0_;
	XiLine* _tmp1_;
	XiLine* _tmp2_;
	XiLine* _tmp3_;
	GtkBorder _tmp4_;
	gint64 result;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = self->priv->line_cache;
	_tmp1_ = xi_line_cache_get_line (_tmp0_, line);
	_line = _tmp1_;
	_tmp2_ = _line;
	if (_tmp2_ == NULL) {
		result = (gint64) 0;
		_xi_line_unref0 (_line);
		return result;
	}
	_tmp3_ = _line;
	_tmp4_ = self->priv->padding;
	result = (gint64) xi_line_x_to_index (_tmp3_, x - ((_tmp4_.left + self->priv->gutter_width) + (2 * self->priv->char_width)));
	_xi_line_unref0 (_line);
	return result;
}

static gdouble
xi_edit_view_get_y (XiEditView* self,
                    gint64 line)
{
	GtkBorder _tmp0_;
	GtkAdjustment* _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->priv->padding;
	_tmp1_ = self->priv->_vadjustment;
	_tmp2_ = gtk_adjustment_get_value (_tmp1_);
	_tmp3_ = _tmp2_;
	result = ((line * self->priv->line_height) + _tmp0_.top) - _tmp3_;
	return result;
}

static gpointer
_xi_core_connection_ref0 (gpointer self)
{
	return self ? xi_core_connection_ref (self) : NULL;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
_xi_edit_view_handle_update_xi_core_connection_update_received (XiCoreConnection* _sender,
                                                                JsonObject* update,
                                                                gpointer self)
{
	xi_edit_view_handle_update ((XiEditView*) self, update);
}

static void
_xi_edit_view_handle_scroll_to_xi_core_connection_scroll_to_received (XiCoreConnection* _sender,
                                                                      gint64 line,
                                                                      gint64 col,
                                                                      gpointer self)
{
	xi_edit_view_handle_scroll_to ((XiEditView*) self, line, col);
}

static void
_xi_edit_view_handle_commit_gtk_im_context_commit (GtkIMContext* _sender,
                                                   const gchar* str,
                                                   gpointer self)
{
	xi_edit_view_handle_commit ((XiEditView*) self, str);
}

static void
_xi_edit_view_handle_pressed_gtk_gesture_multi_press_pressed (GtkGestureMultiPress* _sender,
                                                              gint n_press,
                                                              gdouble x,
                                                              gdouble y,
                                                              gpointer self)
{
	xi_edit_view_handle_pressed ((XiEditView*) self, n_press, x, y);
}

static void
_xi_edit_view_handle_drag_update_gtk_gesture_drag_drag_update (GtkGestureDrag* _sender,
                                                               gdouble offset_x,
                                                               gdouble offset_y,
                                                               gpointer self)
{
	xi_edit_view_handle_drag_update ((XiEditView*) self, offset_x, offset_y);
}

static void
_gtk_widget_queue_draw_xi_blinker_redraw (XiBlinker* _sender,
                                          gpointer self)
{
	gtk_widget_queue_draw ((GtkWidget*) self);
}

XiEditView*
xi_edit_view_construct (GType object_type,
                        XiCoreConnection* core_connection,
                        const gchar* view_id,
                        GFile* file)
{
	XiEditView * self = NULL;
	XiCoreConnection* _tmp0_;
	gchar* _tmp1_;
	GFile* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	GtkIMMulticontext* _tmp5_;
	GtkIMContext* _tmp6_;
	GtkGestureMultiPress* _tmp7_;
	GtkGestureMultiPress* _tmp8_;
	GtkGestureDrag* _tmp9_;
	GtkGestureDrag* _tmp10_;
	GtkStyleContext* style_context = NULL;
	GtkStyleContext* _tmp11_;
	GtkStyleContext* _tmp12_;
	GtkStyleContext* _tmp13_;
	GtkStyleContext* _tmp14_;
	GtkBorder _tmp15_ = {0};
	PangoContext* pango_context = NULL;
	PangoContext* _tmp16_;
	PangoFontDescription* font_description = NULL;
	PangoContext* _tmp17_;
	PangoFontDescription* _tmp18_;
	PangoFontMetrics* metrics = NULL;
	PangoContext* _tmp19_;
	PangoFontDescription* _tmp20_;
	PangoFontMetrics* _tmp21_;
	PangoContext* _tmp22_;
	PangoFontDescription* _tmp23_;
	XiLineCache* _tmp24_;
	PangoFontMetrics* _tmp25_;
	PangoFontMetrics* _tmp26_;
	PangoFontMetrics* _tmp27_;
	GtkSettings* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	XiBlinker* _tmp31_;
	XiBlinker* _tmp32_;
	g_return_val_if_fail (core_connection != NULL, NULL);
	g_return_val_if_fail (view_id != NULL, NULL);
	self = (XiEditView*) g_object_new (object_type, NULL);
	_tmp0_ = _xi_core_connection_ref0 (core_connection);
	_xi_core_connection_unref0 (self->priv->core_connection);
	self->priv->core_connection = _tmp0_;
	_tmp1_ = g_strdup (view_id);
	_g_free0 (self->priv->view_id);
	self->priv->view_id = _tmp1_;
	_tmp2_ = _g_object_ref0 (file);
	_g_object_unref0 (self->priv->file);
	self->priv->file = _tmp2_;
	_tmp3_ = g_strconcat ("update-received::", view_id, NULL);
	g_signal_connect_object (core_connection, _tmp3_, (GCallback) _xi_edit_view_handle_update_xi_core_connection_update_received, self, 0);
	_g_free0 (_tmp3_);
	_tmp4_ = g_strconcat ("scroll-to-received::", view_id, NULL);
	g_signal_connect_object (core_connection, _tmp4_, (GCallback) _xi_edit_view_handle_scroll_to_xi_core_connection_scroll_to_received, self, 0);
	_g_free0 (_tmp4_);
	_tmp5_ = (GtkIMMulticontext*) gtk_im_multicontext_new ();
	_g_object_unref0 (self->priv->im_context);
	self->priv->im_context = (GtkIMContext*) _tmp5_;
	_tmp6_ = self->priv->im_context;
	g_signal_connect_object (_tmp6_, "commit", (GCallback) _xi_edit_view_handle_commit_gtk_im_context_commit, self, 0);
	_tmp7_ = (GtkGestureMultiPress*) gtk_gesture_multi_press_new ((GtkWidget*) self);
	_g_object_unref0 (self->priv->multipress_gesture);
	self->priv->multipress_gesture = _tmp7_;
	_tmp8_ = self->priv->multipress_gesture;
	g_signal_connect_object (_tmp8_, "pressed", (GCallback) _xi_edit_view_handle_pressed_gtk_gesture_multi_press_pressed, self, 0);
	_tmp9_ = (GtkGestureDrag*) gtk_gesture_drag_new ((GtkWidget*) self);
	_g_object_unref0 (self->priv->drag_gesture);
	self->priv->drag_gesture = _tmp9_;
	_tmp10_ = self->priv->drag_gesture;
	g_signal_connect_object (_tmp10_, "drag-update", (GCallback) _xi_edit_view_handle_drag_update_gtk_gesture_drag_drag_update, self, 0);
	_tmp11_ = gtk_widget_get_style_context ((GtkWidget*) self);
	style_context = _tmp11_;
	_tmp12_ = style_context;
	gtk_style_context_add_class (_tmp12_, GTK_STYLE_CLASS_MONOSPACE);
	_tmp13_ = style_context;
	_tmp14_ = style_context;
	gtk_style_context_get_padding (_tmp13_, gtk_style_context_get_state (_tmp14_), &_tmp15_);
	self->priv->padding = _tmp15_;
	_tmp16_ = gtk_widget_get_pango_context ((GtkWidget*) self);
	pango_context = _tmp16_;
	_tmp17_ = pango_context;
	_tmp18_ = pango_context_get_font_description (_tmp17_);
	font_description = _tmp18_;
	_tmp19_ = pango_context;
	_tmp20_ = font_description;
	_tmp21_ = pango_context_get_metrics (_tmp19_, _tmp20_, NULL);
	metrics = _tmp21_;
	_tmp22_ = pango_context;
	_tmp23_ = font_description;
	_tmp24_ = xi_line_cache_new (_tmp22_, _tmp23_);
	_xi_line_cache_unref0 (self->priv->line_cache);
	self->priv->line_cache = _tmp24_;
	_tmp25_ = metrics;
	self->priv->ascent = pango_units_to_double (pango_font_metrics_get_ascent (_tmp25_));
	_tmp26_ = metrics;
	self->priv->line_height = self->priv->ascent + pango_units_to_double (pango_font_metrics_get_descent (_tmp26_));
	_tmp27_ = metrics;
	self->priv->char_width = pango_units_to_double (pango_font_metrics_get_approximate_char_width (_tmp27_));
	_tmp28_ = gtk_widget_get_settings ((GtkWidget*) self);
	g_object_get (_tmp28_, "gtk-cursor-blink-time", &_tmp29_, NULL);
	_tmp30_ = _tmp29_;
	_tmp31_ = xi_blinker_new ((guint) (_tmp30_ / 2));
	_xi_blinker_unref0 (self->priv->blinker);
	self->priv->blinker = _tmp31_;
	_tmp32_ = self->priv->blinker;
	g_signal_connect_object (_tmp32_, "redraw", (GCallback) _gtk_widget_queue_draw_xi_blinker_redraw, (GtkWidget*) self, 0);
	gtk_widget_set_can_focus ((GtkWidget*) self, TRUE);
	gtk_widget_set_has_window ((GtkWidget*) self, TRUE);
	gtk_widget_add_events ((GtkWidget*) self, (gint) ((((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_BUTTON_MOTION_MASK) | GDK_SCROLL_MASK) | GDK_SMOOTH_SCROLL_MASK));
	if (file != NULL) {
		gchar* _tmp33_;
		gchar* _tmp34_;
		_tmp33_ = g_file_get_basename (file);
		_tmp34_ = _tmp33_;
		xi_edit_view_set_label (self, _tmp34_);
		_g_free0 (_tmp34_);
	} else {
		xi_edit_view_set_label (self, "untitled");
	}
	_pango_font_metrics_unref0 (metrics);
	return self;
}

XiEditView*
xi_edit_view_new (XiCoreConnection* core_connection,
                  const gchar* view_id,
                  GFile* file)
{
	return xi_edit_view_construct (XI_TYPE_EDIT_VIEW, core_connection, view_id, file);
}

static void
xi_edit_view_real_realize (GtkWidget* base)
{
	XiEditView * self;
	GtkIMContext* _tmp0_;
	GdkWindow* _tmp1_;
	GdkWindow* _tmp2_;
	GdkDisplay* _tmp3_;
	GdkCursor* _tmp4_;
	GdkCursor* _tmp5_;
	self = (XiEditView*) base;
	GTK_WIDGET_CLASS (xi_edit_view_parent_class)->realize ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_drawing_area_get_type (), GtkDrawingArea));
	_tmp0_ = self->priv->im_context;
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) self);
	gtk_im_context_set_client_window (_tmp0_, _tmp1_);
	_tmp2_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp3_ = gtk_widget_get_display ((GtkWidget*) self);
	_tmp4_ = gdk_cursor_new_for_display (_tmp3_, GDK_XTERM);
	_tmp5_ = _tmp4_;
	gdk_window_set_cursor (_tmp2_, _tmp5_);
	_g_object_unref0 (_tmp5_);
}

static void
xi_edit_view_real_size_allocate (GtkWidget* base,
                                 GtkAllocation* allocation)
{
	XiEditView * self;
	GtkAllocation _tmp0_;
	gint64 new_last_line = 0LL;
	GtkAllocation _tmp1_;
	GtkAdjustment* _tmp4_;
	GtkAllocation _tmp5_;
	GtkAdjustment* _tmp6_;
	XiLineCache* _tmp7_;
	GtkBorder _tmp8_;
	GtkBorder _tmp9_;
	GtkAllocation _tmp10_;
	GtkAdjustment* _tmp11_;
	gdouble _tmp12_;
	gdouble _tmp13_;
	GtkAdjustment* _tmp14_;
	gdouble _tmp15_;
	gdouble _tmp16_;
	GtkAdjustment* _tmp17_;
	gdouble _tmp18_;
	gdouble _tmp19_;
	self = (XiEditView*) base;
	g_return_if_fail (allocation != NULL);
	_tmp0_ = *allocation;
	GTK_WIDGET_CLASS (xi_edit_view_parent_class)->size_allocate ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_drawing_area_get_type (), GtkDrawingArea), &_tmp0_);
	_tmp1_ = *allocation;
	new_last_line = xi_edit_view_get_line (self, (gdouble) _tmp1_.height) + 1;
	if (new_last_line != self->priv->last_line) {
		XiCoreConnection* _tmp2_;
		const gchar* _tmp3_;
		self->priv->last_line = new_last_line;
		_tmp2_ = self->priv->core_connection;
		_tmp3_ = self->priv->view_id;
		xi_core_connection_send_scroll (_tmp2_, _tmp3_, self->priv->first_line, self->priv->last_line);
	}
	_tmp4_ = self->priv->_vadjustment;
	_tmp5_ = *allocation;
	gtk_adjustment_set_page_size (_tmp4_, (gdouble) _tmp5_.height);
	_tmp6_ = self->priv->_vadjustment;
	_tmp7_ = self->priv->line_cache;
	_tmp8_ = self->priv->padding;
	_tmp9_ = self->priv->padding;
	_tmp10_ = *allocation;
	gtk_adjustment_set_upper (_tmp6_, MAX (((xi_line_cache_get_height (_tmp7_) * self->priv->line_height) + _tmp8_.top) + _tmp9_.bottom, (gdouble) _tmp10_.height));
	_tmp11_ = self->priv->_vadjustment;
	_tmp12_ = gtk_adjustment_get_value (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = self->priv->_vadjustment;
	_tmp15_ = gtk_adjustment_get_upper (_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = self->priv->_vadjustment;
	_tmp18_ = gtk_adjustment_get_page_size (_tmp17_);
	_tmp19_ = _tmp18_;
	if (_tmp13_ > (_tmp16_ - _tmp19_)) {
		GtkAdjustment* _tmp20_;
		GtkAdjustment* _tmp21_;
		gdouble _tmp22_;
		gdouble _tmp23_;
		GtkAdjustment* _tmp24_;
		gdouble _tmp25_;
		gdouble _tmp26_;
		_tmp20_ = self->priv->_vadjustment;
		_tmp21_ = self->priv->_vadjustment;
		_tmp22_ = gtk_adjustment_get_upper (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = self->priv->_vadjustment;
		_tmp25_ = gtk_adjustment_get_page_size (_tmp24_);
		_tmp26_ = _tmp25_;
		gtk_adjustment_set_value (_tmp20_, _tmp23_ - _tmp26_);
	}
}

static gboolean
xi_edit_view_real_draw (GtkWidget* base,
                        cairo_t* cr)
{
	XiEditView * self;
	XiTheme* _tmp0_;
	XiTheme* _tmp1_;
	GdkRGBA _tmp2_;
	gboolean result;
	self = (XiEditView*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = xi_theme_get_instance ();
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_->background;
	gdk_cairo_set_source_rgba (cr, &_tmp2_);
	_xi_theme_unref0 (_tmp1_);
	cairo_paint (cr);
	{
		gint64 i = 0LL;
		i = self->priv->first_line;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				XiLine* line = NULL;
				XiLineCache* _tmp5_;
				XiLine* _tmp6_;
				XiLine* _tmp7_;
				if (!_tmp3_) {
					gint64 _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				if (!(i < self->priv->last_line)) {
					break;
				}
				_tmp5_ = self->priv->line_cache;
				_tmp6_ = xi_line_cache_get_line (_tmp5_, i);
				line = _tmp6_;
				_tmp7_ = line;
				if (_tmp7_ != NULL) {
					gdouble y = 0.0;
					XiLine* _tmp8_;
					GtkBorder _tmp9_;
					y = xi_edit_view_get_y (self, i);
					_tmp8_ = line;
					_tmp9_ = self->priv->padding;
					xi_line_draw_background (_tmp8_, cr, (_tmp9_.left + self->priv->gutter_width) + (2 * self->priv->char_width), y, (gdouble) gtk_widget_get_allocated_width ((GtkWidget*) self), self->priv->line_height);
				}
				_xi_line_unref0 (line);
			}
		}
	}
	{
		gint64 i = 0LL;
		i = self->priv->first_line;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				XiLine* line = NULL;
				XiLineCache* _tmp12_;
				XiLine* _tmp13_;
				XiLine* _tmp14_;
				if (!_tmp10_) {
					gint64 _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp10_ = FALSE;
				if (!(i < self->priv->last_line)) {
					break;
				}
				_tmp12_ = self->priv->line_cache;
				_tmp13_ = xi_line_cache_get_line (_tmp12_, i);
				line = _tmp13_;
				_tmp14_ = line;
				if (_tmp14_ != NULL) {
					gdouble y = 0.0;
					XiLine* _tmp15_;
					GtkBorder _tmp16_;
					XiBlinker* _tmp17_;
					XiLine* _tmp20_;
					GtkBorder _tmp21_;
					y = xi_edit_view_get_y (self, i);
					_tmp15_ = line;
					_tmp16_ = self->priv->padding;
					xi_line_draw (_tmp15_, cr, (_tmp16_.left + self->priv->gutter_width) + (2 * self->priv->char_width), y, self->priv->ascent);
					_tmp17_ = self->priv->blinker;
					if (xi_blinker_draw_cursor (_tmp17_)) {
						XiLine* _tmp18_;
						GtkBorder _tmp19_;
						_tmp18_ = line;
						_tmp19_ = self->priv->padding;
						xi_line_draw_cursors (_tmp18_, cr, (_tmp19_.left + self->priv->gutter_width) + (2 * self->priv->char_width), y, self->priv->line_height);
					}
					_tmp20_ = line;
					_tmp21_ = self->priv->padding;
					xi_line_draw_gutter (_tmp20_, cr, _tmp21_.left + self->priv->gutter_width, y, self->priv->ascent);
				}
				_xi_line_unref0 (line);
			}
		}
	}
	result = GDK_EVENT_STOP;
	return result;
}

static gboolean
xi_edit_view_real_focus_in_event (GtkWidget* base,
                                  GdkEventFocus* event)
{
	XiEditView * self;
	GtkIMContext* _tmp0_;
	XiBlinker* _tmp1_;
	gboolean result;
	self = (XiEditView*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->im_context;
	gtk_im_context_focus_in (_tmp0_);
	_tmp1_ = self->priv->blinker;
	xi_blinker_restart (_tmp1_);
	result = GDK_EVENT_STOP;
	return result;
}

static gboolean
xi_edit_view_real_focus_out_event (GtkWidget* base,
                                   GdkEventFocus* event)
{
	XiEditView * self;
	GtkIMContext* _tmp0_;
	XiBlinker* _tmp1_;
	gboolean result;
	self = (XiEditView*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->im_context;
	gtk_im_context_focus_out (_tmp0_);
	_tmp1_ = self->priv->blinker;
	xi_blinker_stop (_tmp1_);
	result = GDK_EVENT_STOP;
	return result;
}

static gboolean
xi_edit_view_real_key_press_event (GtkWidget* base,
                                   GdkEventKey* event)
{
	XiEditView * self;
	GtkIMContext* _tmp0_;
	gboolean result;
	self = (XiEditView*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	if (GTK_WIDGET_CLASS (xi_edit_view_parent_class)->key_press_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_drawing_area_get_type (), GtkDrawingArea), event)) {
		result = GDK_EVENT_STOP;
		return result;
	}
	_tmp0_ = self->priv->im_context;
	if (gtk_im_context_filter_keypress (_tmp0_, event)) {
		result = GDK_EVENT_STOP;
		return result;
	}
	result = GDK_EVENT_PROPAGATE;
	return result;
}

static gboolean
xi_edit_view_real_key_release_event (GtkWidget* base,
                                     GdkEventKey* event)
{
	XiEditView * self;
	GtkIMContext* _tmp0_;
	gboolean result;
	self = (XiEditView*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	if (GTK_WIDGET_CLASS (xi_edit_view_parent_class)->key_release_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_drawing_area_get_type (), GtkDrawingArea), event)) {
		result = GDK_EVENT_STOP;
		return result;
	}
	_tmp0_ = self->priv->im_context;
	if (gtk_im_context_filter_keypress (_tmp0_, event)) {
		result = GDK_EVENT_STOP;
		return result;
	}
	result = GDK_EVENT_PROPAGATE;
	return result;
}

static void
xi_edit_view_handle_commit (XiEditView* self,
                            const gchar* str)
{
	XiCoreConnection* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (str != NULL);
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = self->priv->view_id;
	xi_core_connection_send_insert (_tmp0_, _tmp1_, str);
}

static GdkEvent*
_vala_GdkEvent_copy (GdkEvent* self)
{
	return g_boxed_copy (gdk_event_get_type (), self);
}

static gpointer
__vala_GdkEvent_copy0 (gpointer self)
{
	return self ? _vala_GdkEvent_copy (self) : NULL;
}

static void
_vala_GdkEventSequence_free (GdkEventSequence* self)
{
	g_boxed_free (gdk_event_sequence_get_type (), self);
}

static void
_vala_GdkEvent_free (GdkEvent* self)
{
	g_boxed_free (gdk_event_get_type (), self);
}

static void
xi_edit_view_handle_pressed (XiEditView* self,
                             gint n_press,
                             gdouble x,
                             gdouble y)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gint64 line = 0LL;
	gint64 column = 0LL;
	GdkEvent* event = NULL;
	GtkGestureMultiPress* _tmp5_;
	GtkGestureMultiPress* _tmp6_;
	GdkEventSequence* _tmp7_;
	GdkEventSequence* _tmp8_;
	GdkEvent* _tmp9_;
	GdkEvent* _tmp10_;
	GdkEvent* _tmp11_;
	GdkModifierType state = 0U;
	GdkEvent* _tmp12_;
	GdkModifierType _tmp13_ = 0U;
	gboolean modify_selection = FALSE;
	gboolean extend_selection = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = gtk_widget_get_focus_on_click ((GtkWidget*) self);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		gboolean _tmp3_;
		gboolean _tmp4_;
		g_object_get ((GtkWidget*) self, "has-focus", &_tmp3_, NULL);
		_tmp4_ = _tmp3_;
		_tmp0_ = !_tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gtk_widget_grab_focus ((GtkWidget*) self);
	}
	line = xi_edit_view_get_line (self, y);
	column = xi_edit_view_get_index (self, x, line);
	_tmp5_ = self->priv->multipress_gesture;
	_tmp6_ = self->priv->multipress_gesture;
	_tmp7_ = gtk_gesture_single_get_current_sequence ((GtkGestureSingle*) _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = gtk_gesture_get_last_event ((GtkGesture*) _tmp5_, _tmp8_);
	_tmp10_ = __vala_GdkEvent_copy0 (_tmp9_);
	_tmp11_ = _tmp10_;
	__vala_GdkEventSequence_free0 (_tmp8_);
	event = _tmp11_;
	_tmp12_ = event;
	gdk_event_get_state (_tmp12_, &_tmp13_);
	state = _tmp13_;
	modify_selection = (state & gtk_widget_get_modifier_mask ((GtkWidget*) self, GDK_MODIFIER_INTENT_MODIFY_SELECTION)) != 0;
	extend_selection = (state & gtk_widget_get_modifier_mask ((GtkWidget*) self, GDK_MODIFIER_INTENT_EXTEND_SELECTION)) != 0;
	switch (n_press) {
		case 1:
		{
			if (extend_selection) {
				XiCoreConnection* _tmp14_;
				const gchar* _tmp15_;
				_tmp14_ = self->priv->core_connection;
				_tmp15_ = self->priv->view_id;
				xi_core_connection_send_gesture_select_extend (_tmp14_, _tmp15_, line, column, "point");
			} else {
				XiCoreConnection* _tmp16_;
				const gchar* _tmp17_;
				_tmp16_ = self->priv->core_connection;
				_tmp17_ = self->priv->view_id;
				xi_core_connection_send_gesture_select (_tmp16_, _tmp17_, line, column, "point", modify_selection);
			}
			break;
		}
		case 2:
		{
			if (extend_selection) {
				XiCoreConnection* _tmp18_;
				const gchar* _tmp19_;
				_tmp18_ = self->priv->core_connection;
				_tmp19_ = self->priv->view_id;
				xi_core_connection_send_gesture_select_extend (_tmp18_, _tmp19_, line, column, "word");
			} else {
				XiCoreConnection* _tmp20_;
				const gchar* _tmp21_;
				_tmp20_ = self->priv->core_connection;
				_tmp21_ = self->priv->view_id;
				xi_core_connection_send_gesture_select (_tmp20_, _tmp21_, line, column, "word", modify_selection);
			}
			break;
		}
		case 3:
		{
			if (extend_selection) {
				XiCoreConnection* _tmp22_;
				const gchar* _tmp23_;
				_tmp22_ = self->priv->core_connection;
				_tmp23_ = self->priv->view_id;
				xi_core_connection_send_gesture_select_extend (_tmp22_, _tmp23_, line, column, "line");
			} else {
				XiCoreConnection* _tmp24_;
				const gchar* _tmp25_;
				_tmp24_ = self->priv->core_connection;
				_tmp25_ = self->priv->view_id;
				xi_core_connection_send_gesture_select (_tmp24_, _tmp25_, line, column, "line", modify_selection);
			}
			break;
		}
		default:
		break;
	}
	__vala_GdkEvent_free0 (event);
}

static void
xi_edit_view_handle_drag_update (XiEditView* self,
                                 gdouble offset_x,
                                 gdouble offset_y)
{
	gdouble start_x = 0.0;
	gdouble start_y = 0.0;
	GtkGestureDrag* _tmp0_;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gint64 line = 0LL;
	gint64 column = 0LL;
	XiCoreConnection* _tmp3_;
	const gchar* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->drag_gesture;
	gtk_gesture_drag_get_start_point (_tmp0_, &_tmp1_, &_tmp2_);
	start_x = _tmp1_;
	start_y = _tmp2_;
	line = xi_edit_view_get_line (self, start_y + offset_y);
	column = xi_edit_view_get_index (self, start_x + offset_x, line);
	_tmp3_ = self->priv->core_connection;
	_tmp4_ = self->priv->view_id;
	xi_core_connection_send_gesture_drag (_tmp3_, _tmp4_, line, column);
}

static void
xi_edit_view_handle_scroll (XiEditView* self)
{
	gint64 new_first_line = 0LL;
	gint64 new_last_line = 0LL;
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	new_first_line = xi_edit_view_get_line (self, (gdouble) 0);
	new_last_line = xi_edit_view_get_line (self, (gdouble) gtk_widget_get_allocated_height ((GtkWidget*) self)) + 1;
	if (new_first_line != self->priv->first_line) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = new_last_line != self->priv->last_line;
	}
	if (_tmp0_) {
		XiCoreConnection* _tmp1_;
		const gchar* _tmp2_;
		self->priv->first_line = new_first_line;
		self->priv->last_line = new_last_line;
		_tmp1_ = self->priv->core_connection;
		_tmp2_ = self->priv->view_id;
		xi_core_connection_send_scroll (_tmp1_, _tmp2_, self->priv->first_line, self->priv->last_line);
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
}

static void
xi_edit_view_handle_update (XiEditView* self,
                            JsonObject* update)
{
	XiLineCache* _tmp0_;
	GtkAdjustment* _tmp1_;
	XiLineCache* _tmp2_;
	GtkBorder _tmp3_;
	GtkBorder _tmp4_;
	GtkAdjustment* _tmp5_;
	gdouble _tmp6_;
	gdouble _tmp7_;
	GtkAdjustment* _tmp8_;
	gdouble _tmp9_;
	gdouble _tmp10_;
	GtkAdjustment* _tmp11_;
	gdouble _tmp12_;
	gdouble _tmp13_;
	XiLineCache* _tmp21_;
	XiBlinker* _tmp22_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (update != NULL);
	_tmp0_ = self->priv->line_cache;
	xi_line_cache_update (_tmp0_, update);
	_tmp1_ = self->priv->_vadjustment;
	_tmp2_ = self->priv->line_cache;
	_tmp3_ = self->priv->padding;
	_tmp4_ = self->priv->padding;
	gtk_adjustment_set_upper (_tmp1_, MAX (((xi_line_cache_get_height (_tmp2_) * self->priv->line_height) + _tmp3_.top) + _tmp4_.bottom, (gdouble) gtk_widget_get_allocated_height ((GtkWidget*) self)));
	_tmp5_ = self->priv->_vadjustment;
	_tmp6_ = gtk_adjustment_get_value (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = self->priv->_vadjustment;
	_tmp9_ = gtk_adjustment_get_upper (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = self->priv->_vadjustment;
	_tmp12_ = gtk_adjustment_get_page_size (_tmp11_);
	_tmp13_ = _tmp12_;
	if (_tmp7_ > (_tmp10_ - _tmp13_)) {
		GtkAdjustment* _tmp14_;
		GtkAdjustment* _tmp15_;
		gdouble _tmp16_;
		gdouble _tmp17_;
		GtkAdjustment* _tmp18_;
		gdouble _tmp19_;
		gdouble _tmp20_;
		_tmp14_ = self->priv->_vadjustment;
		_tmp15_ = self->priv->_vadjustment;
		_tmp16_ = gtk_adjustment_get_upper (_tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = self->priv->_vadjustment;
		_tmp19_ = gtk_adjustment_get_page_size (_tmp18_);
		_tmp20_ = _tmp19_;
		gtk_adjustment_set_value (_tmp14_, _tmp17_ - _tmp20_);
	}
	_tmp21_ = self->priv->line_cache;
	self->priv->gutter_width = xi_utilities_get_digits (xi_line_cache_get_height (_tmp21_)) * self->priv->char_width;
	_tmp22_ = self->priv->blinker;
	xi_blinker_restart (_tmp22_);
	gtk_widget_queue_draw ((GtkWidget*) self);
	if (json_object_has_member (update, "pristine")) {
		xi_edit_view_set_has_unsaved_changes (self, !json_object_get_boolean_member (update, "pristine"));
	}
}

static void
xi_edit_view_handle_scroll_to (XiEditView* self,
                               gint64 line,
                               gint64 col)
{
	gdouble min_value = 0.0;
	GtkBorder _tmp0_;
	GtkBorder _tmp1_;
	GtkAdjustment* _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	GtkAdjustment* _tmp6_;
	gdouble _tmp7_;
	gdouble _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->padding;
	_tmp1_ = self->priv->padding;
	min_value = ((((line + 1) * self->priv->line_height) + _tmp0_.top) + _tmp1_.bottom) - gtk_widget_get_allocated_height ((GtkWidget*) self);
	_tmp2_ = self->priv->_vadjustment;
	_tmp3_ = gtk_adjustment_get_value (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ < min_value) {
		GtkAdjustment* _tmp5_;
		_tmp5_ = self->priv->_vadjustment;
		gtk_adjustment_set_value (_tmp5_, min_value);
	}
	_tmp6_ = self->priv->_vadjustment;
	_tmp7_ = gtk_adjustment_get_value (_tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_ > (line * self->priv->line_height)) {
		GtkAdjustment* _tmp9_;
		_tmp9_ = self->priv->_vadjustment;
		gtk_adjustment_set_value (_tmp9_, line * self->priv->line_height);
	}
}

static void
__lambda4_ (XiEditView* self,
            GtkClipboard* clipboard,
            const gchar* text)
{
	g_return_if_fail (clipboard != NULL);
	if (text != NULL) {
		XiCoreConnection* _tmp0_;
		const gchar* _tmp1_;
		_tmp0_ = self->priv->core_connection;
		_tmp1_ = self->priv->view_id;
		xi_core_connection_send_paste (_tmp0_, _tmp1_, text);
	}
}

static void
___lambda4__gtk_clipboard_text_received_func (GtkClipboard* clipboard,
                                              const gchar* text,
                                              gpointer self)
{
	__lambda4_ ((XiEditView*) self, clipboard, text);
	g_object_unref (self);
}

static void
xi_edit_view_paste_primary (XiEditView* self)
{
	GtkClipboard* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_clipboard ((GtkWidget*) self, GDK_SELECTION_PRIMARY);
	gtk_clipboard_request_text (_tmp0_, ___lambda4__gtk_clipboard_text_received_func, g_object_ref (self));
}

gboolean
xi_edit_view_save (XiEditView* self)
{
	GFile* _tmp0_;
	XiCoreConnection* _tmp1_;
	const gchar* _tmp2_;
	GFile* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->file;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = self->priv->core_connection;
	_tmp2_ = self->priv->view_id;
	_tmp3_ = self->priv->file;
	_tmp4_ = g_file_get_path (_tmp3_);
	_tmp5_ = _tmp4_;
	xi_core_connection_send_save (_tmp1_, _tmp2_, _tmp5_);
	_g_free0 (_tmp5_);
	result = TRUE;
	return result;
}

void
xi_edit_view_save_as (XiEditView* self,
                      GFile* file)
{
	GFile* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	XiCoreConnection* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = _g_object_ref0 (file);
	_g_object_unref0 (self->priv->file);
	self->priv->file = _tmp0_;
	_tmp1_ = g_file_get_basename (file);
	_tmp2_ = _tmp1_;
	xi_edit_view_set_label (self, _tmp2_);
	_g_free0 (_tmp2_);
	_tmp3_ = self->priv->core_connection;
	_tmp4_ = self->priv->view_id;
	_tmp5_ = g_file_get_path (file);
	_tmp6_ = _tmp5_;
	xi_core_connection_send_save (_tmp3_, _tmp4_, _tmp6_);
	_g_free0 (_tmp6_);
}

const gchar*
xi_edit_view_get_label (XiEditView* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_label;
	result = _tmp0_;
	return result;
}

static void
xi_edit_view_set_label (XiEditView* self,
                        const gchar* value)
{
	gchar* old_value;
	g_return_if_fail (self != NULL);
	old_value = xi_edit_view_get_label (self);
	if (g_strcmp0 (value, old_value) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_label);
		self->priv->_label = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, xi_edit_view_properties[XI_EDIT_VIEW_LABEL_PROPERTY]);
	}
}

gboolean
xi_edit_view_get_has_unsaved_changes (XiEditView* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_has_unsaved_changes;
	return result;
}

static void
xi_edit_view_set_has_unsaved_changes (XiEditView* self,
                                      gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = xi_edit_view_get_has_unsaved_changes (self);
	if (old_value != value) {
		self->priv->_has_unsaved_changes = value;
		g_object_notify_by_pspec ((GObject *) self, xi_edit_view_properties[XI_EDIT_VIEW_HAS_UNSAVED_CHANGES_PROPERTY]);
	}
}

GtkAdjustment*
xi_edit_view_get_hadjustment (XiEditView* self)
{
	GtkAdjustment* result;
	GtkAdjustment* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_hadjustment;
	result = _tmp0_;
	return result;
}

void
xi_edit_view_set_hadjustment (XiEditView* self,
                              GtkAdjustment* value)
{
	GtkAdjustment* old_value;
	g_return_if_fail (self != NULL);
	old_value = xi_edit_view_get_hadjustment (self);
	if (old_value != value) {
		GtkAdjustment* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_hadjustment);
		self->priv->_hadjustment = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, xi_edit_view_properties[XI_EDIT_VIEW_HADJUSTMENT_PROPERTY]);
	}
}

GtkScrollablePolicy
xi_edit_view_get_hscroll_policy (XiEditView* self)
{
	GtkScrollablePolicy result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_hscroll_policy;
	return result;
}

void
xi_edit_view_set_hscroll_policy (XiEditView* self,
                                 GtkScrollablePolicy value)
{
	GtkScrollablePolicy old_value;
	g_return_if_fail (self != NULL);
	old_value = xi_edit_view_get_hscroll_policy (self);
	if (old_value != value) {
		self->priv->_hscroll_policy = value;
		g_object_notify_by_pspec ((GObject *) self, xi_edit_view_properties[XI_EDIT_VIEW_HSCROLL_POLICY_PROPERTY]);
	}
}

GtkAdjustment*
xi_edit_view_get_vadjustment (XiEditView* self)
{
	GtkAdjustment* result;
	GtkAdjustment* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_vadjustment;
	result = _tmp0_;
	return result;
}

static void
_xi_edit_view_handle_scroll_gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                                          gpointer self)
{
	xi_edit_view_handle_scroll ((XiEditView*) self);
}

void
xi_edit_view_set_vadjustment (XiEditView* self,
                              GtkAdjustment* value)
{
	GtkAdjustment* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_vadjustment);
	self->priv->_vadjustment = _tmp0_;
	if (value != NULL) {
		g_signal_connect_object (value, "value-changed", (GCallback) _xi_edit_view_handle_scroll_gtk_adjustment_value_changed, self, 0);
	}
	g_object_notify_by_pspec ((GObject *) self, xi_edit_view_properties[XI_EDIT_VIEW_VADJUSTMENT_PROPERTY]);
}

GtkScrollablePolicy
xi_edit_view_get_vscroll_policy (XiEditView* self)
{
	GtkScrollablePolicy result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_vscroll_policy;
	return result;
}

void
xi_edit_view_set_vscroll_policy (XiEditView* self,
                                 GtkScrollablePolicy value)
{
	GtkScrollablePolicy old_value;
	g_return_if_fail (self != NULL);
	old_value = xi_edit_view_get_vscroll_policy (self);
	if (old_value != value) {
		self->priv->_vscroll_policy = value;
		g_object_notify_by_pspec ((GObject *) self, xi_edit_view_properties[XI_EDIT_VIEW_VSCROLL_POLICY_PROPERTY]);
	}
}

static void
xi_edit_view_real_send_edit (XiEditView* self,
                             const gchar* method)
{
	XiCoreConnection* _tmp0_;
	const gchar* _tmp1_;
	JsonObject* _tmp2_;
	JsonObject* _tmp3_;
	g_return_if_fail (method != NULL);
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = self->priv->view_id;
	_tmp2_ = json_object_new ();
	_tmp3_ = _tmp2_;
	xi_core_connection_send_edit (_tmp0_, _tmp1_, method, _tmp3_);
	_json_object_unref0 (_tmp3_);
}

static void
__lambda5_ (XiEditView* self,
            GObject* obj,
            GAsyncResult* res)
{
	gchar* _result_ = NULL;
	XiCoreConnection* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (res != NULL);
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = xi_core_connection_send_copy_finish (_tmp0_, res);
	_result_ = _tmp1_;
	_tmp2_ = _result_;
	if (_tmp2_ != NULL) {
		GtkClipboard* _tmp3_;
		const gchar* _tmp4_;
		_tmp3_ = gtk_widget_get_clipboard ((GtkWidget*) self, GDK_SELECTION_CLIPBOARD);
		_tmp4_ = _result_;
		gtk_clipboard_set_text (_tmp3_, _tmp4_, -1);
	}
	_g_free0 (_result_);
}

static void
___lambda5__gasync_ready_callback (GObject* source_object,
                                   GAsyncResult* res,
                                   gpointer self)
{
	__lambda5_ ((XiEditView*) self, source_object, res);
	g_object_unref (self);
}

static void
xi_edit_view_real_copy (XiEditView* self)
{
	XiCoreConnection* _tmp0_;
	const gchar* _tmp1_;
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = self->priv->view_id;
	xi_core_connection_send_copy (_tmp0_, _tmp1_, ___lambda5__gasync_ready_callback, g_object_ref (self));
}

static void
__lambda6_ (XiEditView* self,
            GObject* obj,
            GAsyncResult* res)
{
	gchar* _result_ = NULL;
	XiCoreConnection* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (res != NULL);
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = xi_core_connection_send_cut_finish (_tmp0_, res);
	_result_ = _tmp1_;
	_tmp2_ = _result_;
	if (_tmp2_ != NULL) {
		GtkClipboard* _tmp3_;
		const gchar* _tmp4_;
		_tmp3_ = gtk_widget_get_clipboard ((GtkWidget*) self, GDK_SELECTION_CLIPBOARD);
		_tmp4_ = _result_;
		gtk_clipboard_set_text (_tmp3_, _tmp4_, -1);
	}
	_g_free0 (_result_);
}

static void
___lambda6__gasync_ready_callback (GObject* source_object,
                                   GAsyncResult* res,
                                   gpointer self)
{
	__lambda6_ ((XiEditView*) self, source_object, res);
	g_object_unref (self);
}

static void
xi_edit_view_real_cut (XiEditView* self)
{
	XiCoreConnection* _tmp0_;
	const gchar* _tmp1_;
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = self->priv->view_id;
	xi_core_connection_send_cut (_tmp0_, _tmp1_, ___lambda6__gasync_ready_callback, g_object_ref (self));
}

static void
__lambda7_ (XiEditView* self,
            GtkClipboard* clipboard,
            const gchar* text)
{
	g_return_if_fail (clipboard != NULL);
	if (text != NULL) {
		XiCoreConnection* _tmp0_;
		const gchar* _tmp1_;
		_tmp0_ = self->priv->core_connection;
		_tmp1_ = self->priv->view_id;
		xi_core_connection_send_paste (_tmp0_, _tmp1_, text);
	}
}

static void
___lambda7__gtk_clipboard_text_received_func (GtkClipboard* clipboard,
                                              const gchar* text,
                                              gpointer self)
{
	__lambda7_ ((XiEditView*) self, clipboard, text);
	g_object_unref (self);
}

static void
xi_edit_view_real_paste (XiEditView* self)
{
	GtkClipboard* _tmp0_;
	_tmp0_ = gtk_widget_get_clipboard ((GtkWidget*) self, GDK_SELECTION_CLIPBOARD);
	gtk_clipboard_request_text (_tmp0_, ___lambda7__gtk_clipboard_text_received_func, g_object_ref (self));
}

static void
xi_edit_view_real_add_next_to_selection (XiEditView* self)
{
	XiCoreConnection* _tmp0_;
	const gchar* _tmp1_;
	XiCoreConnection* _tmp2_;
	const gchar* _tmp3_;
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = self->priv->view_id;
	xi_core_connection_send_selection_for_find (_tmp0_, _tmp1_, FALSE);
	_tmp2_ = self->priv->core_connection;
	_tmp3_ = self->priv->view_id;
	xi_core_connection_send_find_next (_tmp2_, _tmp3_, TRUE, TRUE, "add");
}

static void
xi_edit_view_class_init (XiEditViewClass * klass,
                         gpointer klass_data)
{
	xi_edit_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &XiEditView_private_offset);
	((GtkWidgetClass *) klass)->realize = (void (*) (GtkWidget*)) xi_edit_view_real_realize;
	((GtkWidgetClass *) klass)->size_allocate = (void (*) (GtkWidget*, GtkAllocation*)) xi_edit_view_real_size_allocate;
	((GtkWidgetClass *) klass)->draw = (gboolean (*) (GtkWidget*, cairo_t*)) xi_edit_view_real_draw;
	((GtkWidgetClass *) klass)->focus_in_event = (gboolean (*) (GtkWidget*, GdkEventFocus*)) xi_edit_view_real_focus_in_event;
	((GtkWidgetClass *) klass)->focus_out_event = (gboolean (*) (GtkWidget*, GdkEventFocus*)) xi_edit_view_real_focus_out_event;
	((GtkWidgetClass *) klass)->key_press_event = (gboolean (*) (GtkWidget*, GdkEventKey*)) xi_edit_view_real_key_press_event;
	((GtkWidgetClass *) klass)->key_release_event = (gboolean (*) (GtkWidget*, GdkEventKey*)) xi_edit_view_real_key_release_event;
	((XiEditViewClass *) klass)->send_edit = xi_edit_view_real_send_edit;
	((XiEditViewClass *) klass)->copy = xi_edit_view_real_copy;
	((XiEditViewClass *) klass)->cut = xi_edit_view_real_cut;
	((XiEditViewClass *) klass)->paste = xi_edit_view_real_paste;
	((XiEditViewClass *) klass)->add_next_to_selection = xi_edit_view_real_add_next_to_selection;
	G_OBJECT_CLASS (klass)->get_property = _vala_xi_edit_view_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_xi_edit_view_set_property;
	G_OBJECT_CLASS (klass)->finalize = xi_edit_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), XI_EDIT_VIEW_LABEL_PROPERTY, xi_edit_view_properties[XI_EDIT_VIEW_LABEL_PROPERTY] = g_param_spec_string ("label", "label", "label", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), XI_EDIT_VIEW_HAS_UNSAVED_CHANGES_PROPERTY, xi_edit_view_properties[XI_EDIT_VIEW_HAS_UNSAVED_CHANGES_PROPERTY] = g_param_spec_boolean ("has-unsaved-changes", "has-unsaved-changes", "has-unsaved-changes", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), XI_EDIT_VIEW_HADJUSTMENT_PROPERTY, xi_edit_view_properties[XI_EDIT_VIEW_HADJUSTMENT_PROPERTY] = g_param_spec_object ("hadjustment", "hadjustment", "hadjustment", gtk_adjustment_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), XI_EDIT_VIEW_HSCROLL_POLICY_PROPERTY, xi_edit_view_properties[XI_EDIT_VIEW_HSCROLL_POLICY_PROPERTY] = g_param_spec_enum ("hscroll-policy", "hscroll-policy", "hscroll-policy", gtk_scrollable_policy_get_type (), 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), XI_EDIT_VIEW_VADJUSTMENT_PROPERTY, xi_edit_view_properties[XI_EDIT_VIEW_VADJUSTMENT_PROPERTY] = g_param_spec_object ("vadjustment", "vadjustment", "vadjustment", gtk_adjustment_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), XI_EDIT_VIEW_VSCROLL_POLICY_PROPERTY, xi_edit_view_properties[XI_EDIT_VIEW_VSCROLL_POLICY_PROPERTY] = g_param_spec_enum ("vscroll-policy", "vscroll-policy", "vscroll-policy", gtk_scrollable_policy_get_type (), 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	xi_edit_view_signals[XI_EDIT_VIEW_SEND_EDIT_SIGNAL] = g_signal_new ("send-edit", XI_TYPE_EDIT_VIEW, G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (XiEditViewClass, send_edit), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	xi_edit_view_signals[XI_EDIT_VIEW_COPY_SIGNAL] = g_signal_new ("copy", XI_TYPE_EDIT_VIEW, G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (XiEditViewClass, copy), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	xi_edit_view_signals[XI_EDIT_VIEW_CUT_SIGNAL] = g_signal_new ("cut", XI_TYPE_EDIT_VIEW, G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (XiEditViewClass, cut), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	xi_edit_view_signals[XI_EDIT_VIEW_PASTE_SIGNAL] = g_signal_new ("paste", XI_TYPE_EDIT_VIEW, G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (XiEditViewClass, paste), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	xi_edit_view_signals[XI_EDIT_VIEW_ADD_NEXT_TO_SELECTION_SIGNAL] = g_signal_new ("add-next-to-selection", XI_TYPE_EDIT_VIEW, G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (XiEditViewClass, add_next_to_selection), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	gtk_widget_class_set_css_name (GTK_WIDGET_CLASS (klass), "xi-editview");
}

static void
xi_edit_view_gtk_scrollable_interface_init (GtkScrollableInterface * iface,
                                            gpointer iface_data)
{
	xi_edit_view_gtk_scrollable_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_border = (gboolean (*) (GtkScrollable*, GtkBorder*)) xi_edit_view_real_get_border;
}

static void
xi_edit_view_instance_init (XiEditView * self,
                            gpointer klass)
{
	self->priv = xi_edit_view_get_instance_private (self);
}

static void
xi_edit_view_finalize (GObject * obj)
{
	XiEditView * self;
	XiCoreConnection* _tmp0_;
	const gchar* _tmp1_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, XI_TYPE_EDIT_VIEW, XiEditView);
	_tmp0_ = self->priv->core_connection;
	_tmp1_ = self->priv->view_id;
	xi_core_connection_send_close_view (_tmp0_, _tmp1_);
	_xi_core_connection_unref0 (self->priv->core_connection);
	_g_free0 (self->priv->view_id);
	_g_object_unref0 (self->priv->file);
	_g_object_unref0 (self->priv->im_context);
	_g_object_unref0 (self->priv->multipress_gesture);
	_g_object_unref0 (self->priv->drag_gesture);
	_xi_line_cache_unref0 (self->priv->line_cache);
	_xi_blinker_unref0 (self->priv->blinker);
	_g_free0 (self->priv->_label);
	_g_object_unref0 (self->priv->_hadjustment);
	_g_object_unref0 (self->priv->_vadjustment);
	G_OBJECT_CLASS (xi_edit_view_parent_class)->finalize (obj);
}

static GType
xi_edit_view_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (XiEditViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) xi_edit_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (XiEditView), 0, (GInstanceInitFunc) xi_edit_view_instance_init, NULL };
	static const GInterfaceInfo gtk_scrollable_info = { (GInterfaceInitFunc) xi_edit_view_gtk_scrollable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType xi_edit_view_type_id;
	xi_edit_view_type_id = g_type_register_static (gtk_drawing_area_get_type (), "XiEditView", &g_define_type_info, 0);
	g_type_add_interface_static (xi_edit_view_type_id, gtk_scrollable_get_type (), &gtk_scrollable_info);
	XiEditView_private_offset = g_type_add_instance_private (xi_edit_view_type_id, sizeof (XiEditViewPrivate));
	return xi_edit_view_type_id;
}

GType
xi_edit_view_get_type (void)
{
	static volatile gsize xi_edit_view_type_id__once = 0;
	if (g_once_init_enter (&xi_edit_view_type_id__once)) {
		GType xi_edit_view_type_id;
		xi_edit_view_type_id = xi_edit_view_get_type_once ();
		g_once_init_leave (&xi_edit_view_type_id__once, xi_edit_view_type_id);
	}
	return xi_edit_view_type_id__once;
}

static void
_vala_xi_edit_view_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec)
{
	XiEditView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, XI_TYPE_EDIT_VIEW, XiEditView);
	switch (property_id) {
		case XI_EDIT_VIEW_LABEL_PROPERTY:
		g_value_set_string (value, xi_edit_view_get_label (self));
		break;
		case XI_EDIT_VIEW_HAS_UNSAVED_CHANGES_PROPERTY:
		g_value_set_boolean (value, xi_edit_view_get_has_unsaved_changes (self));
		break;
		case XI_EDIT_VIEW_HADJUSTMENT_PROPERTY:
		g_value_set_object (value, xi_edit_view_get_hadjustment (self));
		break;
		case XI_EDIT_VIEW_HSCROLL_POLICY_PROPERTY:
		g_value_set_enum (value, xi_edit_view_get_hscroll_policy (self));
		break;
		case XI_EDIT_VIEW_VADJUSTMENT_PROPERTY:
		g_value_set_object (value, xi_edit_view_get_vadjustment (self));
		break;
		case XI_EDIT_VIEW_VSCROLL_POLICY_PROPERTY:
		g_value_set_enum (value, xi_edit_view_get_vscroll_policy (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_xi_edit_view_set_property (GObject * object,
                                 guint property_id,
                                 const GValue * value,
                                 GParamSpec * pspec)
{
	XiEditView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, XI_TYPE_EDIT_VIEW, XiEditView);
	switch (property_id) {
		case XI_EDIT_VIEW_LABEL_PROPERTY:
		xi_edit_view_set_label (self, g_value_get_string (value));
		break;
		case XI_EDIT_VIEW_HAS_UNSAVED_CHANGES_PROPERTY:
		xi_edit_view_set_has_unsaved_changes (self, g_value_get_boolean (value));
		break;
		case XI_EDIT_VIEW_HADJUSTMENT_PROPERTY:
		xi_edit_view_set_hadjustment (self, g_value_get_object (value));
		break;
		case XI_EDIT_VIEW_HSCROLL_POLICY_PROPERTY:
		xi_edit_view_set_hscroll_policy (self, g_value_get_enum (value));
		break;
		case XI_EDIT_VIEW_VADJUSTMENT_PROPERTY:
		xi_edit_view_set_vadjustment (self, g_value_get_object (value));
		break;
		case XI_EDIT_VIEW_VSCROLL_POLICY_PROPERTY:
		xi_edit_view_set_vscroll_policy (self, g_value_get_enum (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

